/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { PiggyBankEventArray } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionLinkArray } from '../model';
// @ts-ignore
import { TransactionSingle } from '../model';
// @ts-ignore
import { TransactionStore } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { TransactionUpdate } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransactionJournal', 'id', id)
            const localVarPath = `/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransaction', 'id', id)
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionByJournal', 'id', id)
            const localVarPath = `/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByTransaction', 'id', id)
            const localVarPath = `/v1/transactions/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEventByTransaction', 'id', id)
            const localVarPath = `/v1/transactions/{id}/piggy-bank-events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listLinksByJournal', 'id', id)
            const localVarPath = `/v1/transaction-journals/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction: async (xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction: async (transactionStore: TransactionStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionStore' is not null or undefined
            assertParamExists('storeTransaction', 'transactionStore', transactionStore)
            const localVarPath = `/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: string, transactionUpdate: TransactionUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transactionUpdate' is not null or undefined
            assertParamExists('updateTransaction', 'transactionUpdate', transactionUpdate)
            const localVarPath = `/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionJournal(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionJournal(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByJournal(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByJournal(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByTransaction(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByTransaction(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventByTransaction(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankEventArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventByTransaction(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLinksByJournal(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLinksByJournal(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransaction(xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransaction(xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTransaction(transactionStore: TransactionStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTransaction(transactionStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: string, transactionUpdate: TransactionUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transactionUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal(id: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionJournal(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id: string, xTraceId?: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransaction(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal(id: string, xTraceId?: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransactionByJournal(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByTransaction(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<PiggyBankEventArray> {
            return localVarFp.listEventByTransaction(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<TransactionLinkArray> {
            return localVarFp.listLinksByJournal(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction(xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransaction(xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction(transactionStore: TransactionStore, xTraceId?: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.storeTransaction(transactionStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: string, transactionUpdate: TransactionUpdate, xTraceId?: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.updateTransaction(id, transactionUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDeleteTransactionRequest
 */
export interface TransactionsApiDeleteTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiDeleteTransaction
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiDeleteTransaction
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for deleteTransactionJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDeleteTransactionJournalRequest
 */
export interface TransactionsApiDeleteTransactionJournalRequest {
    /**
     * The ID of the transaction journal (the split) you wish to delete.
     * @type {string}
     * @memberof TransactionsApiDeleteTransactionJournal
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiDeleteTransactionJournal
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionRequest
 */
export interface TransactionsApiGetTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiGetTransaction
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiGetTransaction
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getTransactionByJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByJournalRequest
 */
export interface TransactionsApiGetTransactionByJournalRequest {
    /**
     * The ID of the transaction journal (split).
     * @type {string}
     * @memberof TransactionsApiGetTransactionByJournal
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiGetTransactionByJournal
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for listAttachmentByTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListAttachmentByTransactionRequest
 */
export interface TransactionsApiListAttachmentByTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly page?: number
}

/**
 * Request parameters for listEventByTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListEventByTransactionRequest
 */
export interface TransactionsApiListEventByTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly page?: number
}

/**
 * Request parameters for listLinksByJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListLinksByJournalRequest
 */
export interface TransactionsApiListLinksByJournalRequest {
    /**
     * The ID of the transaction journal / the split.
     * @type {string}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly page?: number
}

/**
 * Request parameters for listTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListTransactionRequest
 */
export interface TransactionsApiListTransactionRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiListTransaction
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListTransaction
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TransactionsApiListTransaction
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
     * @type {string}
     * @memberof TransactionsApiListTransaction
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
     * @type {string}
     * @memberof TransactionsApiListTransaction
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned.
     * @type {TransactionTypeFilter}
     * @memberof TransactionsApiListTransaction
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiStoreTransactionRequest
 */
export interface TransactionsApiStoreTransactionRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
     * @type {TransactionStore}
     * @memberof TransactionsApiStoreTransaction
     */
    readonly transactionStore: TransactionStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiStoreTransaction
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUpdateTransactionRequest
 */
export interface TransactionsApiUpdateTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiUpdateTransaction
     */
    readonly id: string

    /**
     * JSON array with updated transaction information. See the model for the exact specifications.
     * @type {TransactionUpdate}
     * @memberof TransactionsApiUpdateTransaction
     */
    readonly transactionUpdate: TransactionUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TransactionsApiUpdateTransaction
     */
    readonly xTraceId?: string
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Delete a transaction.
     * @summary Delete a transaction.
     * @param {TransactionsApiDeleteTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(requestParameters: TransactionsApiDeleteTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransaction(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an individual journal (split) from a transaction.
     * @summary Delete split from transaction
     * @param {TransactionsApiDeleteTransactionJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionJournal(requestParameters: TransactionsApiDeleteTransactionJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransactionJournal(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction.
     * @summary Get a single transaction.
     * @param {TransactionsApiGetTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(requestParameters: TransactionsApiGetTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).getTransaction(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction by underlying journal (split).
     * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
     * @param {TransactionsApiGetTransactionByJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByJournal(requestParameters: TransactionsApiGetTransactionByJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionByJournal(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {TransactionsApiListAttachmentByTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listAttachmentByTransaction(requestParameters: TransactionsApiListAttachmentByTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listAttachmentByTransaction(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all piggy bank events.
     * @summary Lists all piggy bank events.
     * @param {TransactionsApiListEventByTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listEventByTransaction(requestParameters: TransactionsApiListEventByTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listEventByTransaction(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
     * @summary Lists all the transaction links for an individual journal (individual split).
     * @param {TransactionsApiListLinksByJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listLinksByJournal(requestParameters: TransactionsApiListLinksByJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listLinksByJournal(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user\'s transactions.
     * @summary List all the user\'s transactions. 
     * @param {TransactionsApiListTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransaction(requestParameters: TransactionsApiListTransactionRequest = {}, options?: any) {
        return TransactionsApiFp(this.configuration).listTransaction(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new transaction
     * @param {TransactionsApiStoreTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public storeTransaction(requestParameters: TransactionsApiStoreTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).storeTransaction(requestParameters.transactionStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing transaction.
     * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
     * @param {TransactionsApiUpdateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(requestParameters: TransactionsApiUpdateTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransaction(requestParameters.id, requestParameters.transactionUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountArray } from '../model';
// @ts-ignore
import { AccountSingle } from '../model';
// @ts-ignore
import { AccountStore } from '../model';
// @ts-ignore
import { AccountTypeFilter } from '../model';
// @ts-ignore
import { AccountUpdate } from '../model';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { PiggyBankArray } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, xTraceId?: string, date?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount: async (xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listPiggyBankByAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/piggy-banks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount: async (id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount: async (accountStore: AccountStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountStore' is not null or undefined
            assertParamExists('storeAccount', 'accountStore', accountStore)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, accountUpdate: AccountUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'accountUpdate' is not null or undefined
            assertParamExists('updateAccount', 'accountUpdate', accountUpdate)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, xTraceId?: string, date?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, xTraceId, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccount(xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccount(xTraceId, limit, page, date, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByAccount(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByAccount(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPiggyBankByAccount(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPiggyBankByAccount(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByAccount(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAccount(accountStore: AccountStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAccount(accountStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, accountUpdate: AccountUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, accountUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccount(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, xTraceId?: string, date?: string, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.getAccount(id, xTraceId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options?: any): AxiosPromise<AccountArray> {
            return localVarFp.listAccount(xTraceId, limit, page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByAccount(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<PiggyBankArray> {
            return localVarFp.listPiggyBankByAccount(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByAccount(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount(accountStore: AccountStore, xTraceId?: string, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.storeAccount(accountStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, accountUpdate: AccountUpdate, xTraceId?: string, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.updateAccount(id, accountUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly xTraceId?: string

    /**
     * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly date?: string
}

/**
 * Request parameters for listAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountRequest
 */
export interface AccountsApiListAccountRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiListAccount
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListAccount
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListAccount
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @type {string}
     * @memberof AccountsApiListAccount
     */
    readonly date?: string

    /**
     * Optional filter on the account type(s) returned
     * @type {AccountTypeFilter}
     * @memberof AccountsApiListAccount
     */
    readonly type?: AccountTypeFilter
}

/**
 * Request parameters for listAttachmentByAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiListAttachmentByAccountRequest
 */
export interface AccountsApiListAttachmentByAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiListAttachmentByAccount
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiListAttachmentByAccount
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListAttachmentByAccount
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListAttachmentByAccount
     */
    readonly page?: number
}

/**
 * Request parameters for listPiggyBankByAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiListPiggyBankByAccountRequest
 */
export interface AccountsApiListPiggyBankByAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiListPiggyBankByAccount
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiListPiggyBankByAccount
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListPiggyBankByAccount
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListPiggyBankByAccount
     */
    readonly page?: number
}

/**
 * Request parameters for listTransactionByAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiListTransactionByAccountRequest
 */
export interface AccountsApiListTransactionByAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned.
     * @type {TransactionTypeFilter}
     * @memberof AccountsApiListTransactionByAccount
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiStoreAccountRequest
 */
export interface AccountsApiStoreAccountRequest {
    /**
     * JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
     * @type {AccountStore}
     * @memberof AccountsApiStoreAccount
     */
    readonly accountStore: AccountStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiStoreAccount
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * The ID of the account.
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * JSON array or formdata with updated account information. See the model for the exact specifications.
     * @type {AccountUpdate}
     * @memberof AccountsApiUpdateAccount
     */
    readonly accountUpdate: AccountUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly xTraceId?: string
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
     * @summary Permanently delete account.
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single account by its ID. 
     * @summary Get single account.
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, requestParameters.xTraceId, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the accounts owned by the authenticated user. 
     * @summary List all accounts.
     * @param {AccountsApiListAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccount(requestParameters: AccountsApiListAccountRequest = {}, options?: any) {
        return AccountsApiFp(this.configuration).listAccount(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.date, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {AccountsApiListAttachmentByAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAttachmentByAccount(requestParameters: AccountsApiListAttachmentByAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).listAttachmentByAccount(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the piggy banks connected to the account. 
     * @summary List all piggy banks related to the account.
     * @param {AccountsApiListPiggyBankByAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listPiggyBankByAccount(requestParameters: AccountsApiListPiggyBankByAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).listPiggyBankByAccount(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the transactions connected to the account. 
     * @summary List all transactions related to the account.
     * @param {AccountsApiListTransactionByAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listTransactionByAccount(requestParameters: AccountsApiListTransactionByAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).listTransactionByAccount(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * @summary Create new account.
     * @param {AccountsApiStoreAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public storeAccount(requestParameters: AccountsApiStoreAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).storeAccount(requestParameters.accountStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
     * @summary Update existing account.
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.accountUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}

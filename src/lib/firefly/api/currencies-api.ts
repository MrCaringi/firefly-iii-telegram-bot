/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountArray } from '../model';
// @ts-ignore
import { AccountTypeFilter } from '../model';
// @ts-ignore
import { AvailableBudgetArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { BillArray } from '../model';
// @ts-ignore
import { BudgetLimitArray } from '../model';
// @ts-ignore
import { CurrencyArray } from '../model';
// @ts-ignore
import { CurrencySingle } from '../model';
// @ts-ignore
import { CurrencyStore } from '../model';
// @ts-ignore
import { CurrencyUpdate } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { RecurrenceArray } from '../model';
// @ts-ignore
import { RuleArray } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency: async (code: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('defaultCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/default`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency: async (code: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency: async (code: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('disableCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/disable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency: async (code: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('enableCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/enable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency: async (code: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultCurrency: async (xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/currencies/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listAccountByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/accounts`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listAvailableBudgetByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/available-budgets`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listBillByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/bills`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listBudgetLimitByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/budget_limits`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency: async (xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listRecurrenceByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/recurrences`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listRuleByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/rules`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency: async (code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listTransactionByCurrency', 'code', code)
            const localVarPath = `/v1/currencies/{code}/transactions`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency: async (currencyStore: CurrencyStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyStore' is not null or undefined
            assertParamExists('storeCurrency', 'currencyStore', currencyStore)
            const localVarPath = `/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency: async (code: string, currencyUpdate: CurrencyUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateCurrency', 'code', code)
            // verify required parameter 'currencyUpdate' is not null or undefined
            assertParamExists('updateCurrency', 'currencyUpdate', currencyUpdate)
            const localVarPath = `/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultCurrency(code: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultCurrency(code, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCurrency(code: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCurrency(code, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableCurrency(code: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableCurrency(code, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableCurrency(code: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableCurrency(code, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrency(code: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrency(code, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultCurrency(xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultCurrency(xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountByCurrency(code, xTraceId, limit, page, date, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableBudgetByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableBudgetByCurrency(code, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBillByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBillByCurrency(code, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimitByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCurrency(xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCurrency(xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecurrenceByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecurrenceByCurrency(code, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleByCurrency(code, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCurrency(currencyStore: CurrencyStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCurrency(currencyStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrency(code: string, currencyUpdate: CurrencyUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrency(code, currencyUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency(code: string, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.defaultCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(code: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency(code: string, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.disableCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency(code: string, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.enableCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(code: string, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.getCurrency(code, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultCurrency(xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.getDefaultCurrency(xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, date?: string, type?: AccountTypeFilter, options?: any): AxiosPromise<AccountArray> {
            return localVarFp.listAccountByCurrency(code, xTraceId, limit, page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AvailableBudgetArray> {
            return localVarFp.listAvailableBudgetByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<BillArray> {
            return localVarFp.listBillByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimitByCurrency(code, xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<CurrencyArray> {
            return localVarFp.listCurrency(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<RecurrenceArray> {
            return localVarFp.listRecurrenceByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRuleByCurrency(code, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency(code: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByCurrency(code, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency(currencyStore: CurrencyStore, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.storeCurrency(currencyStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(code: string, currencyUpdate: CurrencyUpdate, xTraceId?: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.updateCurrency(code, currencyUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for defaultCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiDefaultCurrencyRequest
 */
export interface CurrenciesApiDefaultCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiDefaultCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiDefaultCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for deleteCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiDeleteCurrencyRequest
 */
export interface CurrenciesApiDeleteCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiDeleteCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiDeleteCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for disableCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiDisableCurrencyRequest
 */
export interface CurrenciesApiDisableCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiDisableCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiDisableCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for enableCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiEnableCurrencyRequest
 */
export interface CurrenciesApiEnableCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiEnableCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiEnableCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiGetCurrencyRequest
 */
export interface CurrenciesApiGetCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiGetCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiGetCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getDefaultCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiGetDefaultCurrencyRequest
 */
export interface CurrenciesApiGetDefaultCurrencyRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiGetDefaultCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for listAccountByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListAccountByCurrencyRequest
 */
export interface CurrenciesApiListAccountByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @type {string}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly date?: string

    /**
     * Optional filter on the account type(s) returned
     * @type {AccountTypeFilter}
     * @memberof CurrenciesApiListAccountByCurrency
     */
    readonly type?: AccountTypeFilter
}

/**
 * Request parameters for listAvailableBudgetByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListAvailableBudgetByCurrencyRequest
 */
export interface CurrenciesApiListAvailableBudgetByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListAvailableBudgetByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListAvailableBudgetByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListAvailableBudgetByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListAvailableBudgetByCurrency
     */
    readonly page?: number
}

/**
 * Request parameters for listBillByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListBillByCurrencyRequest
 */
export interface CurrenciesApiListBillByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListBillByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListBillByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListBillByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListBillByCurrency
     */
    readonly page?: number
}

/**
 * Request parameters for listBudgetLimitByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListBudgetLimitByCurrencyRequest
 */
export interface CurrenciesApiListBudgetLimitByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly page?: number

    /**
     * Start date for the budget limit list.
     * @type {string}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly start?: string

    /**
     * End date for the budget limit list.
     * @type {string}
     * @memberof CurrenciesApiListBudgetLimitByCurrency
     */
    readonly end?: string
}

/**
 * Request parameters for listCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListCurrencyRequest
 */
export interface CurrenciesApiListCurrencyRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListCurrency
     */
    readonly page?: number
}

/**
 * Request parameters for listRecurrenceByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListRecurrenceByCurrencyRequest
 */
export interface CurrenciesApiListRecurrenceByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListRecurrenceByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListRecurrenceByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListRecurrenceByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListRecurrenceByCurrency
     */
    readonly page?: number
}

/**
 * Request parameters for listRuleByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListRuleByCurrencyRequest
 */
export interface CurrenciesApiListRuleByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListRuleByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListRuleByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListRuleByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListRuleByCurrency
     */
    readonly page?: number
}

/**
 * Request parameters for listTransactionByCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiListTransactionByCurrencyRequest
 */
export interface CurrenciesApiListTransactionByCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly code: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to limit the list of transactions. 
     * @type {string}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the list of transactions. 
     * @type {string}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof CurrenciesApiListTransactionByCurrency
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiStoreCurrencyRequest
 */
export interface CurrenciesApiStoreCurrencyRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
     * @type {CurrencyStore}
     * @memberof CurrenciesApiStoreCurrency
     */
    readonly currencyStore: CurrencyStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiStoreCurrency
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateCurrency operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiUpdateCurrencyRequest
 */
export interface CurrenciesApiUpdateCurrencyRequest {
    /**
     * The currency code.
     * @type {string}
     * @memberof CurrenciesApiUpdateCurrency
     */
    readonly code: string

    /**
     * JSON array with updated currency information. See the model for the exact specifications.
     * @type {CurrencyUpdate}
     * @memberof CurrenciesApiUpdateCurrency
     */
    readonly currencyUpdate: CurrencyUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CurrenciesApiUpdateCurrency
     */
    readonly xTraceId?: string
}

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
     * @summary Make currency default currency.
     * @param {CurrenciesApiDefaultCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public defaultCurrency(requestParameters: CurrenciesApiDefaultCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).defaultCurrency(requestParameters.code, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a currency.
     * @summary Delete a currency.
     * @param {CurrenciesApiDeleteCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public deleteCurrency(requestParameters: CurrenciesApiDeleteCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).deleteCurrency(requestParameters.code, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a currency.
     * @summary Disable a currency.
     * @param {CurrenciesApiDisableCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public disableCurrency(requestParameters: CurrenciesApiDisableCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).disableCurrency(requestParameters.code, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a single currency.
     * @summary Enable a single currency.
     * @param {CurrenciesApiEnableCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public enableCurrency(requestParameters: CurrenciesApiEnableCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).enableCurrency(requestParameters.code, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single currency.
     * @summary Get a single currency.
     * @param {CurrenciesApiGetCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrency(requestParameters: CurrenciesApiGetCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).getCurrency(requestParameters.code, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s default currency.
     * @summary Get the user\'s default currency.
     * @param {CurrenciesApiGetDefaultCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getDefaultCurrency(requestParameters: CurrenciesApiGetDefaultCurrencyRequest = {}, options?: any) {
        return CurrenciesApiFp(this.configuration).getDefaultCurrency(requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all accounts with this currency.
     * @summary List all accounts with this currency.
     * @param {CurrenciesApiListAccountByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listAccountByCurrency(requestParameters: CurrenciesApiListAccountByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listAccountByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.date, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available budgets with this currency.
     * @summary List all available budgets with this currency.
     * @param {CurrenciesApiListAvailableBudgetByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listAvailableBudgetByCurrency(requestParameters: CurrenciesApiListAvailableBudgetByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listAvailableBudgetByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all bills with this currency.
     * @summary List all bills with this currency.
     * @param {CurrenciesApiListBillByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listBillByCurrency(requestParameters: CurrenciesApiListBillByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listBillByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all budget limits with this currency
     * @summary List all budget limits with this currency
     * @param {CurrenciesApiListBudgetLimitByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listBudgetLimitByCurrency(requestParameters: CurrenciesApiListBudgetLimitByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listBudgetLimitByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all currencies.
     * @summary List all currencies.
     * @param {CurrenciesApiListCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listCurrency(requestParameters: CurrenciesApiListCurrencyRequest = {}, options?: any) {
        return CurrenciesApiFp(this.configuration).listCurrency(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all recurring transactions with this currency.
     * @summary List all recurring transactions with this currency.
     * @param {CurrenciesApiListRecurrenceByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listRecurrenceByCurrency(requestParameters: CurrenciesApiListRecurrenceByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listRecurrenceByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rules with this currency.
     * @summary List all rules with this currency.
     * @param {CurrenciesApiListRuleByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listRuleByCurrency(requestParameters: CurrenciesApiListRuleByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listRuleByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions with this currency.
     * @summary List all transactions with this currency.
     * @param {CurrenciesApiListTransactionByCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listTransactionByCurrency(requestParameters: CurrenciesApiListTransactionByCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).listTransactionByCurrency(requestParameters.code, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new currency
     * @param {CurrenciesApiStoreCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public storeCurrency(requestParameters: CurrenciesApiStoreCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).storeCurrency(requestParameters.currencyStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing currency.
     * @summary Update existing currency.
     * @param {CurrenciesApiUpdateCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public updateCurrency(requestParameters: CurrenciesApiUpdateCurrencyRequest, options?: any) {
        return CurrenciesApiFp(this.configuration).updateCurrency(requestParameters.code, requestParameters.currencyUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}

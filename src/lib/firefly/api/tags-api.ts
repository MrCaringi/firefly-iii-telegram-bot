/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { TagArray } from '../model';
// @ts-ignore
import { TagModelStore } from '../model';
// @ts-ignore
import { TagModelUpdate } from '../model';
// @ts-ignore
import { TagSingle } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tag: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getTag', 'tag', tag)
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag: async (tag: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('listAttachmentByTag', 'tag', tag)
            const localVarPath = `/v1/tags/{tag}/attachments`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag: async (xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag: async (tag: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('listTransactionByTag', 'tag', tag)
            const localVarPath = `/v1/tags/{tag}/transactions`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag: async (tagModelStore: TagModelStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagModelStore' is not null or undefined
            assertParamExists('storeTag', 'tagModelStore', tagModelStore)
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagModelStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tag: string, tagModelUpdate: TagModelUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('updateTag', 'tag', tag)
            // verify required parameter 'tagModelUpdate' is not null or undefined
            assertParamExists('updateTag', 'tagModelUpdate', tagModelUpdate)
            const localVarPath = `/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagModelUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tag: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tag, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByTag(tag: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByTag(tag, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTag(xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTag(xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByTag(tag: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTag(tagModelStore: TagModelStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTag(tagModelStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tag: string, tagModelUpdate: TagModelUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tag, tagModelUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.getTag(tag, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag(tag: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByTag(tag, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag(xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<TagArray> {
            return localVarFp.listTag(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag(tag: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByTag(tag, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag(tagModelStore: TagModelStore, xTraceId?: string, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.storeTag(tagModelStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag: string, tagModelUpdate: TagModelUpdate, xTraceId?: string, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.updateTag(tag, tagModelUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTag operation in TagsApi.
 * @export
 * @interface TagsApiDeleteTagRequest
 */
export interface TagsApiDeleteTagRequest {
    /**
     * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly tag: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getTag operation in TagsApi.
 * @export
 * @interface TagsApiGetTagRequest
 */
export interface TagsApiGetTagRequest {
    /**
     * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @type {string}
     * @memberof TagsApiGetTag
     */
    readonly tag: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiGetTag
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiGetTag
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiGetTag
     */
    readonly page?: number
}

/**
 * Request parameters for listAttachmentByTag operation in TagsApi.
 * @export
 * @interface TagsApiListAttachmentByTagRequest
 */
export interface TagsApiListAttachmentByTagRequest {
    /**
     * Either the tag itself or the tag ID.
     * @type {string}
     * @memberof TagsApiListAttachmentByTag
     */
    readonly tag: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiListAttachmentByTag
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListAttachmentByTag
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListAttachmentByTag
     */
    readonly page?: number
}

/**
 * Request parameters for listTag operation in TagsApi.
 * @export
 * @interface TagsApiListTagRequest
 */
export interface TagsApiListTagRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiListTag
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListTag
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListTag
     */
    readonly page?: number
}

/**
 * Request parameters for listTransactionByTag operation in TagsApi.
 * @export
 * @interface TagsApiListTransactionByTagRequest
 */
export interface TagsApiListTransactionByTagRequest {
    /**
     * Either the tag itself or the tag ID.
     * @type {string}
     * @memberof TagsApiListTransactionByTag
     */
    readonly tag: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiListTransactionByTag
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListTransactionByTag
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof TagsApiListTransactionByTag
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
     * @type {string}
     * @memberof TagsApiListTransactionByTag
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
     * @type {string}
     * @memberof TagsApiListTransactionByTag
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned.
     * @type {TransactionTypeFilter}
     * @memberof TagsApiListTransactionByTag
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeTag operation in TagsApi.
 * @export
 * @interface TagsApiStoreTagRequest
 */
export interface TagsApiStoreTagRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
     * @type {TagModelStore}
     * @memberof TagsApiStoreTag
     */
    readonly tagModelStore: TagModelStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiStoreTag
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateTag operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRequest
 */
export interface TagsApiUpdateTagRequest {
    /**
     * Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly tag: string

    /**
     * JSON array with updated tag information. See the model for the exact specifications.
     * @type {TagModelUpdate}
     * @memberof TagsApiUpdateTag
     */
    readonly tagModelUpdate: TagModelUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly xTraceId?: string
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Delete an tag.
     * @summary Delete an tag.
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: any) {
        return TagsApiFp(this.configuration).deleteTag(requestParameters.tag, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single tag.
     * @summary Get a single tag.
     * @param {TagsApiGetTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(requestParameters: TagsApiGetTagRequest, options?: any) {
        return TagsApiFp(this.configuration).getTag(requestParameters.tag, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {TagsApiListAttachmentByTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listAttachmentByTag(requestParameters: TagsApiListAttachmentByTagRequest, options?: any) {
        return TagsApiFp(this.configuration).listAttachmentByTag(requestParameters.tag, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the user\'s tags.
     * @summary List all tags.
     * @param {TagsApiListTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTag(requestParameters: TagsApiListTagRequest = {}, options?: any) {
        return TagsApiFp(this.configuration).listTag(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions with this tag.
     * @summary List all transactions with this tag.
     * @param {TagsApiListTransactionByTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTransactionByTag(requestParameters: TagsApiListTransactionByTagRequest, options?: any) {
        return TagsApiFp(this.configuration).listTransactionByTag(requestParameters.tag, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new tag
     * @param {TagsApiStoreTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public storeTag(requestParameters: TagsApiStoreTagRequest, options?: any) {
        return TagsApiFp(this.configuration).storeTag(requestParameters.tagModelStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing tag.
     * @summary Update existing tag.
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(requestParameters: TagsApiUpdateTagRequest, options?: any) {
        return TagsApiFp(this.configuration).updateTag(requestParameters.tag, requestParameters.tagModelUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
